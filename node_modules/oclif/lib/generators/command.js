"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const change_case_1 = require("change-case");
const path = require("node:path");
const Generator = require("yeoman-generator");
const { version } = require('../../package.json');
class Command extends Generator {
    options;
    pjson;
    constructor(args, opts) {
        super(args, opts);
        this.options = {
            defaults: opts.defaults,
            force: opts.force,
            name: opts.name,
        };
    }
    async prompting() {
        this.pjson = this.fs.readJSON('package.json');
        if (!this.pjson)
            throw new Error('not in a project directory');
        this.pjson.oclif = this.pjson.oclif || {};
        this.log(`Adding a command to ${this.pjson.name}! Version: ${version}`);
    }
    writing() {
        const cmdPath = this.options.name.split(':').join('/');
        this.sourceRoot(path.join(__dirname, '../../templates'));
        let bin = this.pjson.oclif.bin || this.pjson.oclif.dirname || this.pjson.name;
        if (bin.includes('/'))
            bin = bin.split('/').pop();
        const cmd = `${bin} ${this.options.name}`;
        const commandPath = this.destinationPath(`src/commands/${cmdPath}.ts`);
        const opts = {
            ...this.options,
            bin,
            className: (0, change_case_1.pascalCase)(this.options.name),
            cmd,
            path: commandPath,
            type: 'command',
        };
        this.fs.copyTpl(this.templatePath('src/command.ts.ejs'), commandPath, opts);
        if (this.hasMocha()) {
            this.fs.copyTpl(this.templatePath('test/command.test.ts.ejs'), this.destinationPath(`test/commands/${cmdPath}.test.ts`), opts);
        }
    }
    hasMocha() {
        return Boolean(this.pjson.devDependencies?.mocha);
    }
}
exports.default = Command;
