"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@oclif/core");
const fs_extra_1 = require("fs-extra");
const got_1 = require("got");
const node_child_process_1 = require("node:child_process");
const os = require("node:os");
const path = require("node:path");
const node_stream_1 = require("node:stream");
const node_util_1 = require("node:util");
const semver_1 = require("semver");
const pipeline = (0, node_util_1.promisify)(node_stream_1.pipeline);
async function fileExists(filePath) {
    try {
        await (0, fs_extra_1.access)(filePath);
        return true;
    }
    catch {
        return false;
    }
}
class Manifest extends core_1.Command {
    static args = {
        path: core_1.Args.string({ default: '.', description: 'path to plugin' }),
    };
    static description = 'generates plugin manifest json';
    static flags = {
        jit: core_1.Flags.boolean({
            allowNo: true,
            default: true,
            summary: 'append commands from JIT plugins in manifest',
        }),
    };
    async run() {
        const { flags } = await this.parse(Manifest);
        try {
            (0, fs_extra_1.unlinkSync)('oclif.manifest.json');
        }
        catch { }
        const { args } = await this.parse(Manifest);
        const root = path.resolve(args.path);
        const packageJson = (0, fs_extra_1.readJSONSync)('package.json');
        let jitPluginManifests = [];
        if (flags.jit && packageJson.oclif?.jitPlugins) {
            this.debug('jitPlugins: %s', packageJson.oclif.jitPlugins);
            const tmpDir = os.tmpdir();
            const promises = Object.entries(packageJson.oclif.jitPlugins).map(async ([jitPlugin, version]) => {
                const pluginDir = jitPlugin.replace('/', '-').replace('@', '');
                const fullPath = path.join(tmpDir, pluginDir);
                if (await fileExists(fullPath))
                    await (0, fs_extra_1.remove)(fullPath);
                await (0, fs_extra_1.mkdir)(fullPath, { recursive: true });
                const resolvedVersion = await this.getVersion(jitPlugin, version);
                const tarballUrl = await this.getTarballUrl(jitPlugin, resolvedVersion);
                const tarball = path.join(fullPath, path.basename(tarballUrl));
                await pipeline(got_1.default.stream(tarballUrl), (0, fs_extra_1.createWriteStream)(tarball));
                await this.executeCommand(`tar -xzf "${tarball}"`, { cwd: fullPath });
                const manifest = (await (0, fs_extra_1.readJSON)(path.join(fullPath, 'package', 'oclif.manifest.json')));
                for (const command of Object.values(manifest.commands)) {
                    command.pluginType = 'jit';
                }
                return manifest;
            });
            core_1.ux.action.start('Generating JIT plugin manifests');
            jitPluginManifests = await Promise.all(promises);
            core_1.ux.action.stop();
        }
        let plugin = new core_1.Plugin({
            errorOnManifestCreate: true,
            ignoreManifest: true,
            respectNoCacheDefault: true,
            root,
            type: 'core',
        });
        if (!plugin)
            throw new Error('plugin not found');
        await plugin.load();
        if (!plugin.valid) {
            const { PluginLegacy } = await Promise.resolve().then(() => require('@oclif/plugin-legacy'));
            plugin = new PluginLegacy(this.config, plugin);
            await plugin.load();
        }
        const dotfile = plugin.pjson.files.find((f) => f.endsWith('.oclif.manifest.json'));
        const file = path.join(plugin.root, `${dotfile ? '.' : ''}oclif.manifest.json`);
        for (const manifest of jitPluginManifests) {
            plugin.manifest.commands = { ...plugin.manifest.commands, ...manifest.commands };
        }
        (0, fs_extra_1.writeFileSync)(file, JSON.stringify(plugin.manifest, null, 2));
        this.log(`wrote manifest to ${file}`);
    }
    async executeCommand(command, options) {
        return new Promise((resolve) => {
            (0, node_child_process_1.exec)(command, options, (error, stderr, stdout) => {
                if (error)
                    this.error(error);
                const debugString = options?.cwd
                    ? `executing command: ${command} in ${options.cwd}`
                    : `executing command: ${command}`;
                this.debug(debugString);
                this.debug(stdout);
                this.debug(stderr);
                resolve({ stderr: stderr.toString(), stdout: stdout.toString() });
            });
        });
    }
    async getTarballUrl(plugin, version) {
        const { stderr } = await this.executeCommand(`npm view ${plugin}@${version} --json`);
        const { dist } = JSON.parse(stderr);
        return dist.tarball;
    }
    async getVersion(plugin, version) {
        if (version.startsWith('^') || version.startsWith('~')) {
            // Grab latest from npm to get all the versions so we can find the max satisfying version.
            // We explicitly ask for latest since this command is typically run inside of `npm prepack`,
            // which sets the npm_config_tag env var, which is used as the default anytime a tag isn't
            // provided to `npm view`. This can be problematic if you're building the `nightly` version
            // of a CLI and all the JIT plugins don't have a `nightly` tag themselves.
            // TL;DR - always ask for latest to avoid potentially requesting a non-existent tag.
            const { stderr } = await this.executeCommand(`npm view ${plugin}@latest --json`);
            const { versions } = JSON.parse(stderr);
            return (0, semver_1.maxSatisfying)(versions, version) ?? version.replace('^', '').replace('~', '');
        }
        return version;
    }
}
exports.default = Manifest;
