import _ from "node:path";
import { ESLintUtils as ue, ASTUtils as W } from "@typescript-eslint/utils";
import { minimatch as $ } from "minimatch";
import de from "natural-compare-lite";
import { builtinModules as ce } from "node:module";
let v = ue.RuleCreator(
  (t) => `https://eslint-plugin-perfectionist.azat.io/rules/${t}`
), E = (t, o) => {
  for (let s = 0, l = t.length; s < l; s++) {
    let r = t[s];
    if (o.group === r || Array.isArray(r) && typeof o.group == "string" && r.includes(o.group))
      return s;
  }
  return t.length;
}, O = (t) => {
  let [o, s] = t;
  return s - o;
}, j = (t) => t > 0;
var i = /* @__PURE__ */ ((t) => (t.alphabetical = "alphabetical", t["line-length"] = "line-length", t.natural = "natural", t))(i || {}), c = /* @__PURE__ */ ((t) => (t.desc = "desc", t.asc = "asc", t))(c || {});
let M = (t) => {
  let o, s = (r) => {
    !o && t.flat().includes(r) && (o = r);
  };
  return {
    getGroup: () => o ?? "unknown",
    setCustomGroups: (r, e) => {
      if (r)
        for (let [a, p] of Object.entries(r))
          Array.isArray(p) && p.some(
            (n) => $(e, n, {
              nocomment: !0
            })
          ) && s(a), typeof p == "string" && $(e, p, {
            nocomment: !0
          }) && s(a);
    },
    defineGroup: s
  };
}, A = (t, o, s) => {
  var a, p;
  if ((a = o.dependencies) != null && a.includes(t.name))
    return -1;
  if ((p = t.dependencies) != null && p.includes(o.name))
    return 1;
  let l = s.order === "asc" ? 1 : -1, r, e = (n) => s["ignore-case"] ? n.toLowerCase() : n;
  return s.type === i.alphabetical ? r = (n, u) => e(n.name).localeCompare(e(u.name)) : s.type === i.natural ? r = (n, u) => de(e(n.name), e(u.name)) : r = (n, u) => {
    let y = n.size, m = u.size, f = s["max-line-length"];
    if (f) {
      let d = (g, b) => g > f && b.hasMultipleImportDeclarations;
      d(y, n) && (y = n.name.length + 10), d(m, u) && (m = u.name.length + 10);
    }
    return y - m;
  }, l * r(t, o);
}, w = (t, o) => [...t].sort((s, l) => A(s, l, o)), fe = (t, o) => {
  let s = o.getTokenAfter(t, {
    filter: ({ value: l, type: r }) => !(r === "Punctuator" && [",", ";"].includes(l)),
    includeComments: !0
  });
  return ((s == null ? void 0 : s.type) === "Block" || (s == null ? void 0 : s.type) === "Line") && t.loc.end.line === s.loc.end.line ? s : null;
}, pe = (t, o) => Array.isArray(t) && t.some(
  (s) => $(o.trim(), s, {
    nocomment: !0
  })
) || typeof t == "string" && $(o.trim(), t, {
  nocomment: !0
}) || t === !0, J = (t, o) => {
  let [s, l] = o.getTokensBefore(t, {
    filter: ({ value: r, type: e }) => !(e === "Punctuator" && [",", ";"].includes(r)),
    includeComments: !0,
    count: 2
  });
  return ((l == null ? void 0 : l.type) === "Block" || (l == null ? void 0 : l.type) === "Line") && t.loc.start.line - l.loc.end.line <= 1 && (s == null ? void 0 : s.loc.end.line) !== l.loc.start.line ? l : null;
}, T = (t, o, s) => {
  var p;
  let l = t.range.at(0), r = t.range.at(1), e = o.text.slice(l, r);
  if (W.isParenthesized(t, o)) {
    let n = o.getTokenBefore(
      t,
      W.isOpeningParenToken
    ), u = o.getTokenAfter(
      t,
      W.isClosingParenToken
    );
    l = n.range.at(0), r = u.range.at(1);
  }
  let a = J(t, o);
  if (e.endsWith(";") || e.endsWith(",")) {
    let n = o.getTokensAfter(t, {
      includeComments: !0,
      count: 2
    });
    t.loc.start.line === ((p = n.at(1)) == null ? void 0 : p.loc.start.line) && (r -= 1);
  }
  return a && !pe(
    (s == null ? void 0 : s.partitionComment) ?? !1,
    a.value
  ) && (l = a.range.at(0)), [l, r];
}, L = (t, o, s, l, r) => {
  var p, n;
  let e = [], a = ((p = o.at(0)) == null ? void 0 : p.node.loc.start.line) === ((n = o.at(-1)) == null ? void 0 : n.node.loc.end.line);
  for (let u = 0, y = o.length; u < y; u++) {
    let { node: m } = o.at(u);
    e.push(
      t.replaceTextRange(
        T(m, l, r),
        l.text.slice(
          ...T(s.at(u).node, l, r)
        )
      )
    );
    let f = fe(s.at(u).node, l);
    if (f && !a) {
      let g = [
        l.getTokenBefore(f).range.at(1),
        f.range.at(1)
      ];
      e.push(t.replaceTextRange(g, ""));
      let b = l.getTokenAfter(m);
      e.push(
        t.insertTextAfter(
          (b == null ? void 0 : b.loc.end.line) === m.loc.end.line ? b : m,
          l.text.slice(...g)
        )
      );
    }
  }
  return e;
}, k = (t = {}, o) => Object.assign(o, t), P = (t, o) => {
  if (t.length > 1)
    for (let s = 1; s < t.length; s++) {
      let l = t.at(s - 1), r = t.at(s);
      l && r && o(l, r, s - 1);
    }
};
const X = "sort-svelte-attributes", ge = v({
  name: X,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Svelte attributes"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [c.asc, c.desc],
            default: c.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedSvelteAttributesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: c.asc
    }
  ],
  create: (t) => _.extname(t.filename) !== ".svelte" ? {} : {
    SvelteStartTag: (o) => {
      if (o.attributes.length > 1) {
        let s = k(t.options.at(0), {
          type: i.alphabetical,
          order: c.asc,
          "ignore-case": !1,
          "custom-groups": {},
          groups: []
        }), l = o.attributes.reduce(
          (r, e) => {
            if (e.type === "SvelteSpreadAttribute")
              return r.push([]), r;
            let a, { getGroup: p, defineGroup: n, setCustomGroups: u } = M(
              s.groups
            );
            return e.key.type === "SvelteSpecialDirectiveKey" ? a = t.sourceCode.text.slice(...e.key.range) : typeof e.key.name == "string" ? { name: a } = e.key : a = t.sourceCode.text.slice(...e.key.range), u(s["custom-groups"], a), e.type === "SvelteShorthandAttribute" && (n("svelte-shorthand"), n("shorthand")), (!("value" in e) || Array.isArray(e.value) && !e.value.at(0)) && n("shorthand"), e.loc.start.line !== e.loc.end.line && n("multiline"), r.at(-1).push({
              size: O(e.range),
              node: e,
              group: p(),
              name: a
            }), r;
          },
          [[]]
        );
        for (let r of l)
          P(r, (e, a) => {
            let p = E(s.groups, e), n = E(s.groups, a);
            (p > n || p === n && j(A(e, a, s))) && t.report({
              messageId: "unexpectedSvelteAttributesOrder",
              data: {
                left: e.name,
                right: a.name
              },
              node: a.node,
              fix: (u) => {
                let y = {};
                for (let f of r) {
                  let d = E(s.groups, f);
                  d in y ? y[d] = w(
                    [...y[d], f],
                    s
                  ) : y[d] = [f];
                }
                let m = [];
                for (let f of Object.keys(y).sort(
                  (d, g) => Number(d) - Number(g)
                ))
                  m.push(...w(y[f], s));
                return L(
                  u,
                  r,
                  m,
                  t.sourceCode
                );
              }
            });
          });
      }
    }
  }
}), q = "sort-astro-attributes", ye = v({
  name: q,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Astro attributes"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [c.asc, c.desc],
            default: c.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedAstroAttributesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: c.asc
    }
  ],
  // @ts-ignore
  create: (t) => _.extname(t.filename) !== ".astro" ? {} : {
    JSXElement: (o) => {
      let { attributes: s } = o.openingElement;
      if (s.length > 1) {
        let l = k(t.options.at(0), {
          type: i.alphabetical,
          order: c.asc,
          "ignore-case": !1,
          "custom-groups": {},
          groups: []
        }), r = s.reduce(
          (e, a) => {
            if (a.type === "JSXSpreadAttribute")
              return e.push([]), e;
            let p = typeof a.name.name == "string" ? a.name.name : t.sourceCode.text.slice(...a.name.range), { getGroup: n, defineGroup: u, setCustomGroups: y } = M(
              l.groups
            );
            return y(l["custom-groups"], p), a.type === "AstroShorthandAttribute" && (u("astro-shorthand"), u("shorthand")), a.value === null && u("shorthand"), a.loc.start.line !== a.loc.end.line && u("multiline"), e.at(-1).push({
              size: O(a.range),
              node: a,
              group: n(),
              name: p
            }), e;
          },
          [[]]
        );
        for (let e of r)
          P(e, (a, p) => {
            let n = E(l.groups, a), u = E(l.groups, p);
            (n > u || n === u && j(A(a, p, l))) && t.report({
              messageId: "unexpectedAstroAttributesOrder",
              data: {
                left: a.name,
                right: p.name
              },
              node: p.node,
              fix: (y) => {
                let m = {};
                for (let d of e) {
                  let g = E(l.groups, d);
                  g in m ? m[g] = w(
                    [...m[g], d],
                    l
                  ) : m[g] = [d];
                }
                let f = [];
                for (let d of Object.keys(m).sort(
                  (g, b) => Number(g) - Number(b)
                ))
                  f.push(...w(m[d], l));
                return L(
                  y,
                  e,
                  f,
                  t.sourceCode
                );
              }
            });
          });
      }
    }
  }
});
let I = (t) => t.replaceAll(/\s\s+/g, " ").trim();
const K = "sort-array-includes", me = v({
  name: K,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted arrays before include method"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [c.asc, c.desc],
            default: c.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "spread-last": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedArrayIncludesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: c.asc
    }
  ],
  create: (t) => ({
    MemberExpression: (o) => {
      if ((o.object.type === "ArrayExpression" || o.object.type === "NewExpression") && o.property.type === "Identifier" && o.property.name === "includes") {
        let s = o.object.type === "ArrayExpression" ? o.object.elements : o.object.arguments;
        if (s.length > 1) {
          let l = k(t.options.at(0), {
            type: i.alphabetical,
            order: c.asc,
            "ignore-case": !1,
            "spread-last": !1
          }), r = s.reduce(
            (e, a) => (a !== null && e.at(0).push({
              name: a.type === "Literal" ? `${a.value}` : t.sourceCode.text.slice(...a.range),
              size: O(a.range),
              type: a.type,
              node: a
            }), e),
            [[], []]
          ).flat();
          P(r, (e, a) => {
            let p;
            l["spread-last"] && e.node.type === "Literal" && a.node.type === "SpreadElement" ? p = !1 : l["spread-last"] && e.node.type === "SpreadElement" && a.node.type === "Literal" ? p = !0 : p = j(A(e, a, l)), p && t.report({
              messageId: "unexpectedArrayIncludesOrder",
              data: {
                left: I(e.name),
                right: I(a.name)
              },
              node: a.node,
              fix: (n) => {
                let u = w(r, l);
                if (l["spread-last"])
                  for (let y = 0, m = u.length; y < m; y++)
                    u.at(y).node.type === "SpreadElement" && u.push(u.splice(y, 1).at(0));
                return L(
                  n,
                  r,
                  u,
                  t.sourceCode
                );
              }
            });
          });
        }
      }
    }
  })
}), H = "sort-vue-attributes", he = v({
  name: H,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Vue attributes"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [c.asc, c.desc],
            default: c.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array",
            default: []
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedVueAttributesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: c.asc
    }
  ],
  create: (t) => {
    if (_.extname(t.filename) !== ".vue")
      return {};
    if (!("defineTemplateBodyVisitor" in t.sourceCode.parserServices))
      return {};
    let { defineTemplateBodyVisitor: o } = t.sourceCode.parserServices;
    return o({
      VStartTag: (s) => {
        if (s.attributes.length > 1) {
          let l = k(t.options.at(0), {
            type: i.alphabetical,
            order: c.asc,
            "ignore-case": !1,
            "custom-groups": {},
            groups: []
          }), r = s.attributes.reduce(
            (e, a) => {
              if (a.key.type === "VDirectiveKey" && a.key.name.rawName === "bind")
                return e.push([]), e;
              let p, { getGroup: n, defineGroup: u, setCustomGroups: y } = M(
                l.groups
              );
              return typeof a.key.name == "string" && a.key.type !== "VDirectiveKey" ? p = a.key.rawName : p = t.sourceCode.text.slice(...a.key.range), y(l["custom-groups"], p), a.value === null && u("shorthand"), a.loc.start.line !== a.loc.end.line && u("multiline"), e.at(-1).push({
                size: O(a.range),
                node: a,
                group: n(),
                name: p
              }), e;
            },
            [[]]
          );
          for (let e of r)
            P(e, (a, p) => {
              let n = E(l.groups, a), u = E(l.groups, p);
              (n > u || n === u && j(A(a, p, l))) && t.report({
                messageId: "unexpectedVueAttributesOrder",
                data: {
                  left: a.name,
                  right: p.name
                },
                node: p.node,
                fix: (y) => {
                  let m = {};
                  for (let d of e) {
                    let g = E(l.groups, d);
                    g in m ? m[g] = w(
                      [...m[g], d],
                      l
                    ) : m[g] = [d];
                  }
                  let f = [];
                  for (let d of Object.keys(m).sort(
                    (g, b) => Number(g) - Number(b)
                  ))
                    f.push(...w(m[d], l));
                  return L(
                    y,
                    e,
                    f,
                    t.sourceCode
                  );
                }
              });
            });
        }
      }
    });
  }
}), Q = "sort-named-exports", be = v({
  name: Q,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted named exports"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [c.asc, c.desc],
            default: c.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedNamedExportsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: c.asc
    }
  ],
  create: (t) => ({
    ExportNamedDeclaration: (o) => {
      if (o.specifiers.length > 1) {
        let s = k(t.options.at(0), {
          type: i.alphabetical,
          "ignore-case": !1,
          order: c.asc
        }), l = o.specifiers.map((r) => ({
          size: O(r.range),
          name: r.local.name,
          node: r
        }));
        P(l, (r, e) => {
          j(A(r, e, s)) && t.report({
            messageId: "unexpectedNamedExportsOrder",
            data: {
              left: r.name,
              right: e.name
            },
            node: e.node,
            fix: (a) => L(
              a,
              l,
              w(l, s),
              t.sourceCode
            )
          });
        });
      }
    }
  })
}), Y = "sort-named-imports", xe = v({
  name: Y,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted named imports"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [c.asc, c.desc],
            default: c.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "ignore-alias": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedNamedImportsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: c.asc
    }
  ],
  create: (t) => ({
    ImportDeclaration: (o) => {
      let s = o.specifiers.filter(
        ({ type: l }) => l === "ImportSpecifier"
      );
      if (s.length > 1) {
        let l = k(t.options.at(0), {
          type: i.alphabetical,
          "ignore-alias": !0,
          "ignore-case": !1,
          order: c.asc
        }), r = s.map((e) => {
          let { name: a } = e.local;
          return l["ignore-alias"] && e.type === "ImportSpecifier" && ({ name: a } = e.imported), {
            size: O(e.range),
            node: e,
            name: a
          };
        });
        P(r, (e, a) => {
          j(A(e, a, l)) && t.report({
            messageId: "unexpectedNamedImportsOrder",
            data: {
              left: e.name,
              right: a.name
            },
            node: a.node,
            fix: (p) => L(
              p,
              r,
              w(r, l),
              t.sourceCode
            )
          });
        });
      }
    }
  })
});
let z = (t, o, s) => t.lines.slice(
  o.node.loc.end.line,
  s.node.loc.start.line - 1
).filter((r) => !r.trim().length).length;
const Z = "sort-object-types", Ee = v({
  name: Z,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted object types"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [c.asc, c.desc],
            default: c.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array",
            default: []
          },
          "partition-by-new-line": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedObjectTypesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: c.asc
    }
  ],
  create: (t) => ({
    TSTypeLiteral: (o) => {
      if (o.members.length > 1) {
        let s = k(t.options.at(0), {
          "partition-by-new-line": !1,
          type: i.alphabetical,
          "ignore-case": !1,
          order: c.asc,
          "custom-groups": {},
          groups: []
        }), l = o.members.reduce(
          (r, e) => {
            var N, h, C, x;
            let a, p = t.sourceCode.text.slice(
              e.range.at(0),
              e.range.at(1)
            ), n = (N = r.at(-1)) == null ? void 0 : N.at(-1), { getGroup: u, defineGroup: y, setCustomGroups: m } = M(
              s.groups
            ), f = (S) => S.replace(/(,|;)$/, "");
            if (e.type === "TSPropertySignature")
              e.key.type === "Identifier" ? { name: a } = e.key : e.key.type === "Literal" ? a = `${e.key.value}` : a = t.sourceCode.text.slice(
                e.range.at(0),
                (h = e.typeAnnotation) == null ? void 0 : h.range.at(0)
              );
            else if (e.type === "TSIndexSignature") {
              let S = ((C = e.typeAnnotation) == null ? void 0 : C.range.at(0)) ?? e.range.at(1);
              a = f(
                t.sourceCode.text.slice(e.range.at(0), S)
              );
            } else
              a = f(
                t.sourceCode.text.slice(
                  e.range.at(0),
                  e.range.at(1)
                )
              );
            m(s["custom-groups"], a), e.loc.start.line !== e.loc.end.line && y("multiline");
            let g = p.endsWith(";") || p.endsWith(",") ? 1 : 0, b = {
              size: O(e.range) - g,
              node: e,
              name: a
            };
            return s["partition-by-new-line"] && n && z(t.sourceCode, n, b) && r.push([]), (x = r.at(-1)) == null || x.push({
              ...b,
              group: u()
            }), r;
          },
          [[]]
        );
        for (let r of l)
          P(r, (e, a) => {
            let p = E(s.groups, e), n = E(s.groups, a);
            (p > n || p === n && j(A(e, a, s))) && t.report({
              messageId: "unexpectedObjectTypesOrder",
              data: {
                left: I(e.name),
                right: I(a.name)
              },
              node: a.node,
              fix: (u) => {
                let y = {};
                for (let f of r) {
                  let d = E(s.groups, f);
                  d in y ? y[d] = w(
                    [...y[d], f],
                    s
                  ) : y[d] = [f];
                }
                let m = [];
                for (let f of Object.keys(y).sort(
                  (d, g) => Number(d) - Number(g)
                ))
                  m.push(...w(y[f], s));
                return L(
                  u,
                  r,
                  m,
                  t.sourceCode
                );
              }
            });
          });
      }
    }
  })
}), F = "sort-union-types", Ce = v({
  name: F,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted union types"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [c.asc, c.desc],
            default: c.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "nullable-last": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedUnionTypesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: c.asc
    }
  ],
  create: (t) => ({
    TSUnionType: (o) => {
      let s = k(t.options.at(0), {
        type: i.alphabetical,
        "nullable-last": !1,
        "ignore-case": !1,
        order: c.asc
      }), l = o.types.map((r) => ({
        group: r.type === "TSNullKeyword" || r.type === "TSUndefinedKeyword" ? "nullable" : "unknown",
        name: t.sourceCode.text.slice(...r.range),
        size: O(r.range),
        node: r
      }));
      P(l, (r, e) => {
        let a = j(A(r, e, s));
        s["nullable-last"] && (r.group === "nullable" && e.group === "unknown" ? a = !0 : r.group === "unknown" && e.group === "nullable" && (a = !1)), a && t.report({
          messageId: "unexpectedUnionTypesOrder",
          data: {
            left: I(r.name),
            right: I(e.name)
          },
          node: e.node,
          fix: (p) => {
            let n = [];
            if (s["nullable-last"]) {
              let u = [], y = l.filter((m) => m.group === "nullable" ? (u.push(m), !1) : !0);
              n = [
                ...w(y, s),
                ...w(u, s)
              ];
            } else
              n = w(l, s);
            return L(p, l, n, t.sourceCode);
          }
        });
      });
    }
  })
}), ee = "sort-interfaces", Ne = v({
  name: ee,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted interface properties"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [c.asc, c.desc],
            default: c.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "ignore-pattern": {
            items: {
              type: "string"
            },
            type: "array"
          },
          groups: {
            type: "array",
            default: []
          },
          "partition-by-new-line": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedInterfacePropertiesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: c.asc
    }
  ],
  create: (t) => ({
    TSInterfaceDeclaration: (o) => {
      if (o.body.body.length > 1) {
        let s = k(t.options.at(0), {
          "partition-by-new-line": !1,
          type: i.alphabetical,
          "ignore-case": !1,
          order: c.asc,
          "ignore-pattern": [],
          "custom-groups": {},
          groups: []
        });
        if (!s["ignore-pattern"].some(
          (l) => $(o.id.name, l, {
            nocomment: !0
          })
        )) {
          let l = o.body.body.reduce(
            (r, e) => {
              var f, d, g, b;
              if (e.type === "TSCallSignatureDeclaration")
                return r.push([]), r;
              let a = (f = r.at(-1)) == null ? void 0 : f.at(-1), p, { getGroup: n, defineGroup: u, setCustomGroups: y } = M(
                s.groups
              );
              if (e.type === "TSPropertySignature")
                if (e.key.type === "Identifier")
                  ({ name: p } = e.key);
                else if (e.key.type === "Literal")
                  p = `${e.key.value}`;
                else {
                  let N = ((d = e.typeAnnotation) == null ? void 0 : d.range.at(0)) ?? e.range.at(1) - (e.optional ? 1 : 0);
                  p = t.sourceCode.text.slice(e.range.at(0), N);
                }
              else if (e.type === "TSIndexSignature") {
                let N = ((g = e.typeAnnotation) == null ? void 0 : g.range.at(0)) ?? e.range.at(1);
                p = t.sourceCode.text.slice(
                  e.range.at(0),
                  N
                );
              } else {
                let N = ((b = e.returnType) == null ? void 0 : b.range.at(0)) ?? e.range.at(1);
                p = t.sourceCode.text.slice(
                  e.range.at(0),
                  N
                );
              }
              let m = {
                size: O(e.range),
                node: e,
                name: p
              };
              return s["partition-by-new-line"] && a && z(
                t.sourceCode,
                a,
                m
              ) && r.push([]), y(s["custom-groups"], p), e.loc.start.line !== e.loc.end.line && u("multiline"), r.at(-1).push({
                ...m,
                group: n()
              }), r;
            },
            [[]]
          );
          for (let r of l)
            P(r, (e, a) => {
              let p = E(s.groups, e), n = E(s.groups, a);
              (p > n || p === n && j(A(e, a, s))) && t.report({
                messageId: "unexpectedInterfacePropertiesOrder",
                data: {
                  left: I(e.name),
                  right: I(a.name)
                },
                node: a.node,
                fix: (u) => {
                  let y = {};
                  for (let f of r) {
                    let d = E(s.groups, f);
                    d in y ? y[d] = w(
                      [...y[d], f],
                      s
                    ) : y[d] = [f];
                  }
                  let m = [];
                  for (let f of Object.keys(y).sort(
                    (d, g) => Number(d) - Number(g)
                  ))
                    m.push(...w(y[f], s));
                  return L(
                    u,
                    r,
                    m,
                    t.sourceCode
                  );
                }
              });
            });
        }
      }
    }
  })
}), te = "sort-jsx-props", we = v({
  name: te,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted JSX props"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [c.asc, c.desc],
            default: c.asc,
            type: "string"
          },
          groups: {
            type: "array"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedJSXPropsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: c.asc
    }
  ],
  create: (t) => [".svelte", ".astro", ".vue"].includes(_.extname(t.filename)) ? {} : {
    JSXElement: (o) => {
      if (o.openingElement.attributes.length > 1) {
        let s = k(t.options.at(0), {
          type: i.alphabetical,
          "ignore-case": !1,
          order: c.asc,
          "custom-groups": {},
          groups: []
        }), l = o.openingElement.attributes.reduce(
          (r, e) => {
            if (e.type === "JSXSpreadAttribute")
              return r.push([]), r;
            let a = e.name.type === "JSXNamespacedName" ? `${e.name.namespace.name}:${e.name.name.name}` : e.name.name, { getGroup: p, defineGroup: n, setCustomGroups: u } = M(
              s.groups
            );
            u(s["custom-groups"], a), e.value === null && n("shorthand"), e.loc.start.line !== e.loc.end.line && n("multiline");
            let y = {
              size: O(e.range),
              group: p(),
              node: e,
              name: a
            };
            return r.at(-1).push(y), r;
          },
          [[]]
        );
        for (let r of l)
          P(r, (e, a) => {
            let p = E(s.groups, e), n = E(s.groups, a);
            (p > n || p === n && j(A(e, a, s))) && t.report({
              messageId: "unexpectedJSXPropsOrder",
              data: {
                left: e.name,
                right: a.name
              },
              node: a.node,
              fix: (u) => {
                let y = {};
                for (let f of r) {
                  let d = E(s.groups, f);
                  d in y ? y[d] = w(
                    [...y[d], f],
                    s
                  ) : y[d] = [f];
                }
                let m = [];
                for (let f of Object.keys(y).sort(
                  (d, g) => Number(d) - Number(g)
                ))
                  m.push(...w(y[f], s));
                return L(
                  u,
                  r,
                  m,
                  t.sourceCode
                );
              }
            });
          });
      }
    }
  }
}), re = "sort-exports", Se = v({
  name: re,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted exports"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [c.asc, c.desc],
            default: c.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedExportsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: c.asc
    }
  ],
  create: (t) => {
    let o = k(t.options.at(0), {
      type: i.alphabetical,
      order: c.asc,
      "ignore-case": !1
    }), s = [[]], l = (r) => {
      r.type === "ExportAllDeclaration" && r.exported === null ? s.push([]) : s.at(-1).push({
        size: O(r.range),
        name: r.source.value,
        node: r
      });
    };
    return {
      ExportAllDeclaration: l,
      ExportNamedDeclaration: (r) => {
        r.source !== null && l(r);
      },
      "Program:exit": () => {
        for (let r of s)
          P(r, (e, a) => {
            j(A(e, a, o)) && t.report({
              messageId: "unexpectedExportsOrder",
              data: {
                left: e.name,
                right: a.name
              },
              node: a.node,
              fix: (p) => L(
                p,
                r,
                w(r, o),
                t.sourceCode
              )
            });
          });
      }
    };
  }
}), se = "sort-imports", Ae = v({
  name: se,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted imports"
    },
    fixable: "code",
    schema: [
      {
        id: "sort-imports",
        type: "object",
        properties: {
          "custom-groups": {
            type: "object",
            properties: {
              type: {
                type: "object"
              },
              value: {
                type: "object"
              }
            },
            additionalProperties: !1
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [c.asc, c.desc],
            default: c.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array",
            default: []
          },
          "internal-pattern": {
            items: {
              type: "string"
            },
            type: "array"
          },
          "newlines-between": {
            enum: [
              "ignore",
              "always",
              "never"
              /* never */
            ],
            default: "always",
            type: "string"
          },
          "max-line-length": {
            type: "integer",
            minimum: 0,
            exclusiveMinimum: !0
          }
        },
        allOf: [
          { $ref: "#/definitions/max-line-length-requires-line-length-type" }
        ],
        additionalProperties: !1,
        dependencies: {
          "max-line-length": ["type"]
        },
        definitions: {
          "is-line-length": {
            properties: {
              type: { enum: [i["line-length"]], type: "string" }
            },
            required: ["type"],
            type: "object"
          },
          "max-line-length-requires-line-length-type": {
            anyOf: [
              {
                not: { required: ["max-line-length"], type: "object" },
                type: "object"
              },
              { $ref: "#/definitions/is-line-length" }
            ]
          }
        }
      }
    ],
    messages: {
      unexpectedImportsOrder: 'Expected "{{right}}" to come before "{{left}}"',
      missedSpacingBetweenImports: 'Missed spacing between "{{left}}" and "{{right}}" imports',
      extraSpacingBetweenImports: 'Extra spacing between "{{left}}" and "{{right}}" imports'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: c.asc
    }
  ],
  create: (t) => {
    let o = k(t.options.at(0), {
      "newlines-between": "always",
      "custom-groups": { type: {}, value: {} },
      "internal-pattern": ["~/**"],
      type: i.alphabetical,
      order: c.asc,
      "ignore-case": !1,
      groups: []
    }), s = !1;
    for (let n of o.groups)
      if (Array.isArray(n))
        for (let u of n)
          u === "unknown" && (s = !0);
      else
        n === "unknown" && (s = !0);
    s || (o.groups = [...o.groups, "unknown"]);
    let l = [], r = (n) => n.type === "ImportDeclaration" && n.specifiers.length === 0, e = (n) => {
      let u = (x) => [".less", ".scss", ".sass", ".styl", ".pcss", ".css", ".sss"].some(
        (S) => x.endsWith(S)
      ), y = (x) => [
        "./index.d.js",
        "./index.d.ts",
        "./index.js",
        "./index.ts",
        "./index",
        "./",
        "."
      ].includes(x), m = (x) => x.indexOf("..") === 0, f = (x) => x.indexOf("./") === 0, { getGroup: d, defineGroup: g, setCustomGroups: b } = M(o.groups), N = (x) => o["internal-pattern"].length && o["internal-pattern"].some(
        (S) => $(x.source.value, S, {
          nocomment: !0
        })
      ), h = (x) => {
        let S = [
          "bun",
          "bun:ffi",
          "bun:jsc",
          "bun:sqlite",
          "bun:test",
          "bun:wrap",
          "detect-libc",
          "undici",
          "ws"
        ];
        return ce.includes(
          x.startsWith("node:") ? x.split("node:")[1] : x
        ) || S.includes(x);
      }, C = (x) => !(x.startsWith(".") || x.startsWith("/"));
      return n.importKind === "type" && (n.type === "ImportDeclaration" && (b(o["custom-groups"].type, n.source.value), y(n.source.value) && g("index-type"), f(n.source.value) && g("sibling-type"), m(n.source.value) && g("parent-type"), N(n) && g("internal-type"), h(n.source.value) && g("builtin-type"), C(n.source.value) && g("external-type")), g("type")), n.type === "ImportDeclaration" && (b(o["custom-groups"].value, n.source.value), r(n) && u(n.source.value) && g("side-effect-style"), r(n) && g("side-effect"), u(n.source.value) && g("style"), y(n.source.value) && g("index"), f(n.source.value) && g("sibling"), m(n.source.value) && g("parent"), N(n) && g("internal"), h(n.source.value) && g("builtin"), C(n.source.value) && g("external")), d();
    }, a = (n) => n.specifiers.length > 1, p = (n) => {
      let u;
      n.type === "ImportDeclaration" ? u = n.source.value : n.moduleReference.type === "TSExternalModuleReference" && n.moduleReference.expression.type === "Literal" ? u = `${n.moduleReference.expression.value}` : u = t.sourceCode.text.slice(...n.moduleReference.range), l.push({
        size: O(n.range),
        group: e(n),
        name: u,
        node: n,
        ...o.type === i["line-length"] && o["max-line-length"] && {
          hasMultipleImportDeclarations: a(
            n
          )
        }
      });
    };
    return {
      TSImportEqualsDeclaration: p,
      ImportDeclaration: p,
      "Program:exit": () => {
        var m;
        let n = (f, d) => !!t.sourceCode.getTokensBetween(
          f.node,
          J(d.node, t.sourceCode) || d.node,
          {
            includeComments: !0
          }
        ).length, u = (f, d) => {
          let g = [], b = {};
          for (let h of d) {
            let C = E(o.groups, h);
            C in b ? b[C] = w(
              [...b[C], h],
              o
            ) : b[C] = [h];
          }
          let N = Object.keys(b).sort((h, C) => Number(h) - Number(C)).reduce(
            (h, C) => [
              ...h,
              ...b[C]
            ],
            []
          );
          for (let h = 0, C = N.length; h < C; h++) {
            let x = N.at(h);
            if (g.push(
              f.replaceTextRange(
                T(d.at(h).node, t.sourceCode),
                t.sourceCode.text.slice(
                  ...T(x.node, t.sourceCode)
                )
              )
            ), o["newlines-between"] !== "ignore") {
              let S = N.at(h + 1);
              if (S) {
                let G = z(
                  t.sourceCode,
                  d.at(h),
                  d.at(h + 1)
                );
                (o["newlines-between"] === "always" && E(o.groups, x) === E(o.groups, S) && G !== 0 || o["newlines-between"] === "never" && G > 0) && g.push(
                  f.removeRange([
                    T(
                      d.at(h).node,
                      t.sourceCode
                    ).at(1),
                    T(
                      d.at(h + 1).node,
                      t.sourceCode
                    ).at(0) - 1
                  ])
                ), o["newlines-between"] === "always" && E(o.groups, x) !== E(o.groups, S) && G > 1 && g.push(
                  f.replaceTextRange(
                    [
                      T(
                        d.at(h).node,
                        t.sourceCode
                      ).at(1),
                      T(
                        d.at(h + 1).node,
                        t.sourceCode
                      ).at(0) - 1
                    ],
                    `
`
                  )
                ), o["newlines-between"] === "always" && E(o.groups, x) !== E(o.groups, S) && G === 0 && g.push(
                  f.insertTextAfterRange(
                    T(d.at(h).node, t.sourceCode),
                    `
`
                  )
                );
              }
            }
          }
          return g;
        }, y = [[]];
        for (let f of l) {
          let d = (m = y.at(-1)) == null ? void 0 : m.at(-1);
          d && n(d, f) ? y.push([f]) : y.at(-1).push(f);
        }
        for (let f of y)
          P(f, (d, g) => {
            let b = E(o.groups, d), N = E(o.groups, g), h = z(
              t.sourceCode,
              d,
              g
            );
            !(r(d.node) && r(g.node)) && !n(d, g) && (b > N || b === N && j(A(d, g, o))) && t.report({
              messageId: "unexpectedImportsOrder",
              data: {
                left: d.name,
                right: g.name
              },
              node: g.node,
              fix: (C) => u(C, f)
            }), o["newlines-between"] === "never" && h > 0 && t.report({
              messageId: "extraSpacingBetweenImports",
              data: {
                left: d.name,
                right: g.name
              },
              node: g.node,
              fix: (C) => u(C, f)
            }), o["newlines-between"] === "always" && (b < N && h === 0 ? t.report({
              messageId: "missedSpacingBetweenImports",
              data: {
                left: d.name,
                right: g.name
              },
              node: g.node,
              fix: (C) => u(C, f)
            }) : (h > 1 || b === N && h > 0) && t.report({
              messageId: "extraSpacingBetweenImports",
              data: {
                left: d.name,
                right: g.name
              },
              node: g.node,
              fix: (C) => u(C, f)
            }));
          });
      }
    };
  }
}), ae = "sort-objects", Ie = v({
  name: ae,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted objects"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          "partition-by-comment": {
            type: ["boolean", "string", "array"],
            default: !1
          },
          "partition-by-new-line": {
            type: "boolean",
            default: !1
          },
          "styled-components": {
            type: "boolean",
            default: !0
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [c.asc, c.desc],
            default: c.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "ignore-pattern": {
            items: {
              type: "string"
            },
            type: "array"
          },
          groups: {
            type: "array"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedObjectsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: c.asc
    }
  ],
  create: (t) => {
    let o = (s) => {
      let l = k(t.options.at(0), {
        "partition-by-new-line": !1,
        "partition-by-comment": !1,
        type: i.alphabetical,
        "styled-components": !0,
        "ignore-case": !1,
        "ignore-pattern": [],
        order: c.asc,
        "custom-groups": {},
        groups: []
      }), r = s.parent.type === "VariableDeclarator" && s.parent.id.type === "Identifier" ? s.parent.id.name : null;
      if (!(l["ignore-pattern"].length && typeof r == "string" ? l["ignore-pattern"].some(
        (a) => $(r, a, {
          nocomment: !0
        })
      ) : !1) && s.properties.length > 1) {
        let a = (u) => u.type === "Identifier" && u.name === "styled", p = (u) => u !== void 0 && u.type === "CallExpression" && (u.callee.type === "MemberExpression" && a(u.callee.object) || u.callee.type === "CallExpression" && a(u.callee.callee));
        if (!l["styled-components"] && (p(s.parent) || s.parent.type === "ArrowFunctionExpression" && p(s.parent.parent)))
          return;
        let n = (u) => u.reduce(
          (y, m) => {
            var G;
            if (m.type === "SpreadElement" || m.type === "RestElement")
              return y.push([]), y;
            let f = J(m, t.sourceCode), d = (G = y.at(-1)) == null ? void 0 : G.at(-1);
            l["partition-by-comment"] && f && pe(
              l["partition-by-comment"],
              f.value
            ) && y.push([]);
            let g, b = "ignore", N = [], { getGroup: h, setCustomGroups: C } = M(l.groups);
            m.key.type === "Identifier" ? { name: g } = m.key : m.key.type === "Literal" ? g = `${m.key.value}` : g = t.sourceCode.text.slice(...m.key.range);
            let x = {
              size: O(m.range),
              node: m,
              name: g
            };
            l["partition-by-new-line"] && d && z(t.sourceCode, d, x) && y.push([]), m.value.type === "AssignmentPattern" && ((B) => {
              B.right.type === "Identifier" && N.push(B.right.name);
              let ie = (R) => {
                let D = [];
                switch (R.type) {
                  case "ArrowFunctionExpression":
                    D.push(R.body);
                    break;
                  case "ConditionalExpression":
                    D.push(R.consequent, R.alternate);
                    break;
                  case "LogicalExpression":
                  case "BinaryExpression":
                    D.push(R.left, R.right);
                    break;
                  case "CallExpression":
                    D.push(...R.arguments);
                    break;
                }
                D.forEach((U) => {
                  U.type === "Identifier" && N.push(U.name), (U.type === "BinaryExpression" || U.type === "ConditionalExpression") && ie(U);
                });
              };
              switch (B.right.type) {
                case "ArrowFunctionExpression":
                case "ConditionalExpression":
                case "LogicalExpression":
                case "BinaryExpression":
                case "CallExpression":
                  ie(B.right);
                  break;
              }
            })(m.value), C(l["custom-groups"], g);
            let S = {
              ...x,
              group: h(),
              dependencies: N,
              position: b
            };
            return y.at(-1).push(S), y;
          },
          [[]]
        );
        for (let u of n(s.properties))
          P(u, (y, m) => {
            let f = E(l.groups, y), d = E(l.groups, m);
            if (f > d || f === d && j(A(y, m, l))) {
              let g = (b) => {
                let N = {};
                for (let C of u) {
                  let x = E(l.groups, C);
                  x in N ? N[x] = w(
                    [...N[x], C],
                    l
                  ) : N[x] = [C];
                }
                let h = [];
                for (let C of Object.keys(N).sort(
                  (x, S) => Number(x) - Number(S)
                ))
                  h.push(...w(N[C], l));
                return L(
                  b,
                  u,
                  h,
                  t.sourceCode,
                  {
                    partitionComment: l["partition-by-comment"]
                  }
                );
              };
              t.report({
                messageId: "unexpectedObjectsOrder",
                data: {
                  left: I(y.name),
                  right: I(m.name)
                },
                node: m.node,
                fix: g
              });
            }
          });
      }
    };
    return {
      ObjectExpression: o,
      ObjectPattern: o
    };
  }
}), oe = "sort-classes", ve = v({
  name: oe,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted classes"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          order: {
            enum: [c.asc, c.desc],
            default: c.asc,
            type: "string"
          },
          groups: {
            type: "array",
            default: []
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedClassesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: c.asc
    }
  ],
  create: (t) => ({
    ClassBody: (o) => {
      if (o.body.length > 1) {
        let s = k(t.options.at(0), {
          type: i.alphabetical,
          order: c.asc,
          "ignore-case": !1,
          groups: ["property", "constructor", "method", "unknown"]
        }), l = o.body.map((r) => {
          var u;
          let e, { getGroup: a, defineGroup: p } = M(s.groups);
          r.type === "StaticBlock" ? e = "static" : r.type === "TSIndexSignature" ? e = t.sourceCode.text.slice(
            r.range.at(0),
            ((u = r.typeAnnotation) == null ? void 0 : u.range.at(0)) ?? r.range.at(1)
          ) : r.key.type === "Identifier" ? { name: e } = r.key : e = t.sourceCode.text.slice(...r.key.range);
          let n = e.startsWith("_") || e.startsWith("#");
          if (r.type === "MethodDefinition") {
            r.kind === "constructor" && p("constructor");
            let y = r.accessibility === "private" || n, m = r.static;
            y && m && p("static-private-method"), y && p("private-method"), m && p("static-method"), r.kind === "get" && p("get-method"), r.kind === "set" && p("set-method"), p("method");
          } else
            r.type === "TSIndexSignature" ? p("index-signature") : r.type === "PropertyDefinition" && ((r.accessibility === "private" || n) && p("private-property"), r.static && p("static-property"), p("property"));
          return {
            size: O(r.range),
            group: a(),
            node: r,
            name: e
          };
        });
        P(l, (r, e) => {
          let a = E(s.groups, r), p = E(s.groups, e);
          r.name !== e.name && (a > p || a === p && j(A(r, e, s))) && t.report({
            messageId: "unexpectedClassesOrder",
            data: {
              left: I(r.name),
              right: I(e.name)
            },
            node: e.node,
            fix: (n) => {
              let u = [], y = l.reduce(
                (f, d) => {
                  let g = E(s.groups, d);
                  return g in f ? f[g] = w(
                    [...f[g], d],
                    s
                  ) : f[g] = [d], f;
                },
                {}
              ), m = Object.keys(y).sort((f, d) => Number(f) - Number(d)).reduce(
                (f, d) => [
                  ...f,
                  ...y[d]
                ],
                []
              );
              for (let f = 0, d = m.length; f < d; f++)
                u.push(
                  n.replaceTextRange(
                    T(l.at(f).node, t.sourceCode),
                    t.sourceCode.text.slice(
                      ...T(
                        m.at(f).node,
                        t.sourceCode
                      )
                    )
                  )
                );
              return u;
            }
          });
        });
      }
    }
  })
}), ne = "sort-enums", Oe = v({
  name: ne,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted TypeScript enums"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          order: {
            enum: [c.asc, c.desc],
            default: c.asc,
            type: "string"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedEnumsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: c.asc
    }
  ],
  create: (t) => ({
    TSEnumDeclaration: (o) => {
      if (o.members.length > 1 && o.members.every(({ initializer: s }) => s)) {
        let s = k(t.options.at(0), {
          type: i.alphabetical,
          order: c.asc,
          "ignore-case": !1
        }), l = o.members.map((r) => ({
          name: r.id.type === "Literal" ? `${r.id.value}` : `${t.sourceCode.text.slice(...r.id.range)}`,
          size: O(r.range),
          node: r
        }));
        P(l, (r, e) => {
          j(A(r, e, s)) && t.report({
            messageId: "unexpectedEnumsOrder",
            data: {
              left: I(r.name),
              right: I(e.name)
            },
            node: e.node,
            fix: (a) => L(
              a,
              l,
              w(l, s),
              t.sourceCode
            )
          });
        });
      }
    }
  })
}), le = "sort-maps", je = v({
  name: le,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Map elements"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [c.asc, c.desc],
            default: c.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedMapElementsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: c.asc
    }
  ],
  create: (t) => ({
    NewExpression: (o) => {
      if (o.callee.type === "Identifier" && o.callee.name === "Map" && o.arguments.length && o.arguments[0].type === "ArrayExpression") {
        let [{ elements: s }] = o.arguments;
        if (s.length > 1) {
          let l = k(t.options.at(0), {
            type: i.alphabetical,
            "ignore-case": !1,
            order: c.asc
          }), r = s.reduce(
            (e, a) => (a === null || a.type === "SpreadElement" ? e.push([]) : e.at(-1).push(a), e),
            [[]]
          );
          for (let e of r) {
            let a = e.map((p) => {
              let n;
              if (p.type === "ArrayExpression") {
                let [u] = p.elements;
                u ? u.type === "Literal" ? n = u.raw : n = t.sourceCode.text.slice(...u.range) : n = `${u}`;
              } else
                n = t.sourceCode.text.slice(...p.range);
              return {
                size: O(p.range),
                node: p,
                name: n
              };
            });
            P(a, (p, n) => {
              j(A(p, n, l)) && t.report({
                messageId: "unexpectedMapElementsOrder",
                data: {
                  left: I(p.name),
                  right: I(n.name)
                },
                node: n.node,
                fix: (u) => L(
                  u,
                  a,
                  w(a, l),
                  t.sourceCode
                )
              });
            });
          }
        }
      }
    }
  })
}), ke = "eslint-plugin-perfectionist";
let V = (t) => {
  let o = {
    [se]: [
      "error",
      {
        groups: [
          "type",
          ["builtin", "external"],
          "internal-type",
          "internal",
          ["parent-type", "sibling-type", "index-type"],
          ["parent", "sibling", "index"],
          "object",
          "unknown"
        ],
        "custom-groups": {
          value: {},
          type: {}
        },
        "newlines-between": "always",
        "internal-pattern": ["~/**"]
      }
    ],
    [oe]: [
      "error",
      {
        groups: [
          "index-signature",
          "static-property",
          "private-property",
          "property",
          "constructor",
          "static-method",
          "private-method",
          "method",
          ["get-method", "set-method"],
          "unknown"
        ]
      }
    ],
    [ae]: [
      "error",
      {
        "partition-by-comment": !1
      }
    ],
    [K]: [
      "error",
      {
        "spread-last": !0
      }
    ],
    [X]: ["error"],
    [q]: ["error"],
    [H]: ["error"],
    [Q]: ["error"],
    [Y]: ["error"],
    [Z]: ["error"],
    [F]: ["error"],
    [ee]: ["error"],
    [te]: ["error"],
    [re]: ["error"],
    [ne]: ["error"],
    [le]: ["error"]
  };
  return {
    rules: Object.fromEntries(
      Object.entries(o).map(([s, [l, r = {}]]) => [
        `perfectionist/${s}`,
        [l, Object.assign(r, t)]
      ])
    ),
    plugins: ["perfectionist"]
  };
};
const $e = {
  rules: {
    [K]: me,
    [q]: ye,
    [oe]: ve,
    [ne]: Oe,
    [re]: Se,
    [se]: Ae,
    [ee]: Ne,
    [te]: we,
    [le]: je,
    [Q]: be,
    [Y]: xe,
    [Z]: Ee,
    [ae]: Ie,
    [X]: ge,
    [F]: Ce,
    [H]: he
  },
  configs: {
    "recommended-alphabetical": V({
      type: i.alphabetical,
      order: c.asc,
      "ignore-case": !1
    }),
    "recommended-natural": V({
      type: i.natural,
      order: c.asc,
      "ignore-case": !1
    }),
    "recommended-line-length": V({
      type: i["line-length"],
      order: c.desc
    })
  },
  name: ke
};
export {
  $e as default
};
